代码生成

```go
package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

var structName = flag.String("t", "", "t type")
var output = flag.String("output", "", "output file name; default srcdir/<type>_gen.go")

var noString = flag.Bool("noString", false, "don't gen string")
var noJson = flag.Bool("noJson", false, "don't gen json")

func main() {
	flag.Parse()

	if *structName == "" {
		println("type can not be nil")
		return
	}

	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}
	dir := args[0]

	pkg, err := build.Default.ImportDir(dir, 0)
	if err != nil {
		log.Fatalf("cannot process directory %s: %s", dir, err)
	}
	fmt.Printf("%+v\n", pkg)
	fileList := pkg.GoFiles

	data := `"` + *structName + "[ "
	gen := false
	for _, fl := range fileList {
		src, err := os.Open(dir + "/" + fl)
		if err != nil {
			log.Fatalf("cannot process directory %s: %s", dir, err)
		}

		fset := token.NewFileSet() // positions are relative to fset
		f, err := parser.ParseFile(fset, src.Name(), src, 0)
		if err != nil {
			panic(err)
		}
		ast.FilterFile(f, func(s string) bool {
			return s == *structName
			//return true
		})
		ast.Inspect(f, func(node ast.Node) bool {

			switch val := node.(type) {
			case *ast.StructType:
				if gen {
					gen = false
					for _, field := range val.Fields.List {
						for _, name := range field.Names {
							data += strings.Replace(`%rep=%v `, "%rep", name.Name, -1)
						}
					}
					data += `]"`
					for _, field := range val.Fields.List {
						for _, name := range field.Names {
							data += fmt.Sprintf(", s.%v", name.Name)
						}
					}
				}

			case *ast.GenDecl:
				for _, spe := range val.Specs {
					//fmt.Println("val.Specs", spe, reflect.TypeOf(spe).String())
					if spe.(*ast.TypeSpec).Name.Name == *structName {
						gen = true
					}
				}
			default:
				//if val != nil && reflect.TypeOf(val) != nil {
				//	fmt.Println(reflect.TypeOf(val), val)
				//}
			}
			return true
		})
	}
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_gen.go", strings.ToLower(*structName))
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}

	// Write to file.
	tem, err := template.New("jack").Parse(stringTemplate)
	if err != nil {
		log.Fatalf("parse template error: %s", err)
	}
	outputFile, err := os.Create(outputName)
	if err != nil {
		log.Fatalf("create file output error: %s", err)
	}

	var renderData = map[string]string{
		"packageName": pkg.Name,
		"structName":  *structName,
		"word":        data,
		"genDbMethod": "true",
	}
	if *noJson {
		renderData["notGenJson"] = "true"
	}
	if *noString {
		renderData["notGenString"] = "true"
	}
	err = tem.Execute(outputFile, renderData)
	if err != nil {
		log.Fatalf("render template error: %s", err)
	}
}

const stringTemplate = `// Code generated by "my_gen"; 
package {{.packageName}}

import (
	"errors"
	"fmt"
	"github.com/jinzhu/gorm"
	"github.com/json-iterator/go"
)
var json = jsoniter.ConfigCompatibleWithStandardLibrary
{{if .notGenString}}{{else}}
func (s *{{.structName}}) String() string {
	return fmt.Sprintf(
		{{.word}},
	)
}{{end}}
{{if .notGenJson}}{{else}}
func (s *{{.structName}}) ToJson() []byte {
	if s == nil {
		return []byte{}
	}
	data,err := json.Marshal(s)
	if err != nil {
		return []byte{}
	}
	return data
}
{{end}}
func (s *{{.structName}}) FromJson(data []byte) error {
	if s == nil {
		return errors.New("nil pointer")
	}
	return json.Unmarshal(data,s)
}
{{if .genDbMethod}}
func (s *{{.structName}}) TableName() string {
	return "{{.structName}}"
}

func Get{{.structName}}ById(id int64) (*{{.structName}}, error) {
	monitor := func(){} // TODO replace db monitor method
	defer monitor()
	// TODO replace get db method
	DB := func() *gorm.DB { return nil }
	res := &{{.structName}}{}
	err := DB().Model(res).Where("id = ?",id).Find(res).Error
	
	return res, err
}
{{end}}

type {{.structName}}List []*{{.structName}}

func (list {{.structName}}List) ToMap() map[int64]*{{.structName}} {
	res := make(map[int64]*{{.structName}},len(list))
	for _, item := range list {
		// TODO replace key
		res[item.Id] = item
	}
	return res
}

func (list {{.structName}}List) Range(f func(item *{{.structName}}) error ) error {
	for _,item := range list {
		err := f(item)
		if err != nil {
			return err
		}
	}
	return nil
}
`

```